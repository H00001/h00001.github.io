# 一个智能化的os kernel [机密]

>  IOT 时代下的智能化内核

这个的 os 的理念应用于「IOT」，属于分布式普适系统。



# 模块化-智能操作系统

## 模块化的操作系统，操作系统如果模块一样组装

![img](https://bkimg.cdn.bcebos.com/pic/ac6eddc451da81cb226e0cb75666d0160924313b)
在接口设计原则中，模块的划分和规定好模块之间的接口。如果我们在划分模块时，将模块划分得太小，虽然可以降低模块本身的复杂性，但会引起模块之间的联系过多，而会造成系统比较混乱；如果将模块划分得过大，又会增加模块内部的复杂性，使内部的联系增加。因此，在划分模块时，应在两者之间进行权衡。

## 模块

模块是构成系统的最基本的单位 , 它包含数据和过程。 在操作系统的设计中 , 系统按资源管 理 的观点 划分成若干个模块 , 每个模块管理某一类资源 , 如某类外部设备、或缓冲区等 。 我们用 「数据表示」 来抽象系统资源 。 这样 , 每个模块就包含着一定的数据结构 , 以及在此数据结构上定 的所有操作(一组过程) 。 我们规定 : 模块内的数据只能通过定义在模块中的这 些操作去读取和修改 。 模块间通 过规定的方式和一定数量的接口相连接 。 每个模块都可以独立编译 , 若干个模块按若干个模块按 照一定方式可以联合成为一个系统。

## 模块接口

模块接口通过系统核心锁提供，模块生产者按照既定的方式去生产模块接口，在接口执行过程中，会评估执行效率，对于系统内核模块做热替换？。如果在分布式系统中某个系统缺少某个模块，那么系统会根据RPC去掉用其他的分布式系统节点，对于该模块进行获取。同时，性能好的模块也会进行分布式系统内部传播。

## 动态的用户级别接口组织 

用户接口层面，可以通过深度学习（此处我也不太懂）来自组织形成用户级别的接口给用户使用，用户也可以自主编写接口的实现进行替换，当然这仅仅存在于用户层。

## 系统分层

1. 核 心 

   我们的核心是RPC，内存管理，进程管理，这些管理方式主要用于管理下一级别功能的执行，不用于管理用户进程的执行，用户进程的执行使用中间层的任务管理进行管理。该层主要实现操作系统最基础的功能，保证一个系统能够正常运行，而分布式的系统设计主要集中在下一层。这一层的模块连接使用静态库的方式进行组织，在操作系统内核编译的过程中可以确定执行函数的地址，函数有固定的执行地址。

2. 第二层 

   第二层为任务管理，资源管理，接口管理，事件管理，虚拟文件管理模块 , 它们为用户作业空间提供了非常基础的重要分布式服务，用户编程过程中不会感受到他们的存在，但是这些模块一定要存在于系统中，使用动态库的方式做映射，在操作系统内核编译的过程中可以确定执行函数的相对地址，运行过程中可以通过保护模块进行热插拔，热插拔过程中请求会进入请求队列处理。

# 分布式操作系统


![Untitled Diagram](https://h00001.github.io/data/u.svg)






| node role       | node job                                                     |
| --------------- | :----------------------------------------------------------- |
| Data node       | It can calculate at itself. Data nodes can backup each other and communicate with each other for distributed computing. |
| calculator node | Assign the calculation task to the data node, summarize the calculation result of the data node, and pass it to the control node |
| Control node    | The control node can communicate with other control nodes and vote on some events. |
| config center   | config parameters                                            |

soft bus:用来传递数据和事件[event]

注释：投票包括一些智能化的部署，例如 camera 自动化探测选择范围。

根据这个设计理念，设计出的操作系统内核

## kernel

> 我们做的是一个智能化的，分布式的内核，使用者不知道他是一个系统，还是多个系统，但是操作他们和操作一个系统是一样的。

所有的事情，用户只需要调用就好，不需要知道他来自哪里，也不需要知道如何执行

![main](https://h00001.github.io/data/main.svg)

解释：

1. 内核包括 RPC 系统，内存管理，进程管理。一切远程调用都是用 RPC 模块进行底层执行。
2. 中间层主要用于分布式联动，包括分配分布式任务，整个体系的资源管理，整个体系的借口汇总，软总线管理，事件管理。
3. 用户可以进行接口 export，这种接口导出可以传播到整个系统，分布式系统的其他节点可以进行调用。
4. 事件[event]: 可以是系统事件，也可以是用户事件。事件会随总线进行传播，传递给其他节点进行响应。其他节点如同响应本地事件一样。
5. 协调服务，包括所需要的分布式锁，分布式队列相关基础服务
6. 所有的用户只能使用用户态编程，若是想使用内核服务，必须调用内核 `handle` 使用内核服务。

## 优势

### 远程调用

调用远程的资源，如同调用本地的资源一样，用户也无需显式记忆资源所处于的位置，而只需要使用即可。

用户可以对设备进行编程，系统级别的将接口导出，导出的接口可以在整个分布式系统中传播。

例如用户可以对 camera 进行编程，导出 `screemshort()->picture`·接口，在分布式系统中进行传递，那么对于控制中心进行编程，完全可以直接调用函数

```
camera[camera_id].screemshort()
```

这样调用如同调用本地资源一样。

### 远程进程间通信

远程进程间通信和本地进程间通信一样，用户无需获知这个进程所处于的位置，只需要按照本地的方式使用即可，内核会选择一条最合理的通道，速度和方式进行远程通信。当然，分布式锁也属于远程进程通信的一种。

### 分布式事件

事件由一个事件源发出，传播到整个系统，编程者可以对事件进行响应。例如

发送者：

```c
event_manage->send(URGENCY,1,"The door was damaged")
```

响应者：

```scala
event_manage->register_user(1,fn_door_open)
def fn_door_open(message *msg){
  // 门被破坏，响铃
  ring.parallels.stream(_.doRing)
  //当然，铃也在远程，导出<function> doRing()
}
```

#### 软总线中断

优先级很高的事件，会随软中线传播到整个系统，分布式系统中的其他部分必须对这个事件作出响应，这个中断可以打断其他任务执行，一般用在紧急任务处理。

### 动态注册

新的节点接口可以动态注册到系统中，也可以离开或转移。例如，可以动态向系统添加数据节点「建议不开源」，也可以动态删除这个节点，这些对于内核的用户都是没有感知的。

### 用户进程迁移

1. 分布式系统会定期扫描系统节点压力情况，针对有压力过大的节点，对内部执行的进程进行迁移，迁移到压力小的节点。
2. 如果该节点有更加紧急的任务。

### 任务迁移

分配者肯定会将任务分配到离该任务数据最近的数据节点进行计算，但是，当系统发生变化时，任务会进行迁移到其他节点。以对于数据计算进行优化适应。

### 任务拆分

task manager会合理拆分任务，分配到其他节点。当然也会根据系统当前运行状态，选择不同的拆分方案。开发者可以使用一种 `fork/join `/`map/reduce`的开发模式，在代码中主动进行任务拆分。

### 点对点通信

遇到需要高速，紧急地数据，task manager会和通信节点之间建立临时紧急通道，例如TCP，UPD，串口通道，用来快速传输数据。方式的不同导致通道的性能影响会进行记录和分析。随着建立通道的学习，会根据算法选择最优的方式。这个操作对用户没有感知。例如：使用者观看高清摄像头数据，高清视频数据会建立视频节点到控制节点，甚至智能˙终端节点的直接数据通道，这个通道在停止观看后被销毁。

### 统一的参数管理

使用配置中心，统一管理系统参数。这个参数会根据使用发生变化，直到达到最优的参数。

### 统一的资源管理

整个系统如同一个系统一样，会将所有资源进行整合，用户级别的进程，也可以称作为任务，任务可以被分配在任意的节点执行，同时任务也可以进行迁移，拆分，跃迁。同时，整个系统之存在一个虚拟文件目录。

### 可配置的优先级，绑定的执行节点

计算节点，优先级可以由编程者主动设置，这样一些很紧急的任务不会因为得不到执行产生事故。

### 内核任务向上迁移

将许多内核界别的任务，向上移动到了用户层，这样底层开发着可以根据系统情况配置系统。

## 举个🌰

操作一个分布式系统，就像操作系统一个系统一样，只需要对于操作系统的一点就行编程，就可以传递给到这个系统，

---

written by FrankHan

